# -*- coding: utf-8 -*-
"""MM-FLOOD_Inference.ipynb

Automatically generated by 

Original file is located at
    https://colab.research.google.com/drive/1swMkxr12Oy0y3j1y4lWqn_EDvo4ASv2G
"""

import rasterio
import numpy as np
import os
from Unet_models import UNet
from focal_loss import BinaryFocalLoss
import matplotlib.pyplot as plt


















# Run prediction on patches
predicted_patches = []
xai_patches = []

for patch in patches:
    # patch = bandeq(patch)
    print(patch.shape, patch.min(), patch.max(), patch.dtype, patch.mean(axis = (0,1,2)), patch.std(axis=(0,1,2)))

    patch = np.expand_dims(patch, axis = 0)
    print("patch : ", patch.shape)

    pred = unet_model.predict(patch)
    prediction = np.squeeze(pred, axis = 0)
    print("pred : ", prediction.shape, prediction.min(), prediction.max(), prediction.dtype)

    # Apply threshold to the predicted mask
    thresh_pred = (prediction > prediction.mean()).astype(int)
    print("thresh pred : ", thresh_pred.shape, thresh_pred.min(), thresh_pred.max(), thresh_pred.dtype)

    heatmap = generate_grad_cam(unet_model, patch)

    # Create a 1x4 subplot
    fig, axes = plt.subplots(1, 4, figsize=(16, 4))

    # Plot the images on each subplot
    axes[0].imshow(prediction[:,:,:], cmap='gray')
    axes[0].set_title('Pred')
    axes[0].axis('off')

    axes[1].imshow(patch[0,:,:,0], cmap='gray')
    axes[1].set_title('VV')
    axes[1].axis('off')

    axes[2].imshow(patch[0,:,:,1], cmap='gray')
    axes[2].set_title('VH')
    axes[2].axis('off')

    axes[3].imshow(heatmap, cmap='gray')
    axes[3].set_title('Grad - CAM')
    axes[3].axis('off')

    # Adjust layout
    plt.tight_layout()
    plt.show()

    predicted_patches.append(prediction)
    xai_patches.append(heatmap)

# Convert the list of predicted patches to a numpy array
predicted_patches = np.array(predicted_patches)
print(predicted_patches.shape)

# Reconstruct the image from predicted patches
reconstructed_image = reconstruct_image_from_patches(predicted_patches, (2560,2560,1))
print(reconstructed_image.shape)

# Reconstruct the image from predicted patches
reconstructed_original_image = reconstruct_image_from_patches(patches, (2560,2560,2))
print(reconstructed_original_image.shape)

# Convert the list of predicted patches to a numpy array
xai_patches = np.array(xai_patches)
print(xai_patches.shape)

# Reconstruct the image from predicted patches
reconstructed_xai_image = reconstruct_image_from_patches(xai_patches, (2560,2560,1))
print(reconstructed_xai_image.shape)

# Plot the reconstructed image
plt.figure(figsize=(8, 8))
plt.imshow(reconstructed_image, cmap='jet', aspect='auto')  # Assuming grayscale image
plt.axis('off')
plt.title('Reconstructed Image')
plt.colorbar()
plt.show()

# Plot the reconstructed image
plt.imshow(reconstructed_original_image[:,:,0], cmap='gray')  # Assuming grayscale image
plt.axis('off')
plt.title('Reconstructed Image')
plt.show()

# Plot the reconstructed image
plt.imshow(reconstructed_original_image[:,:,1], cmap='gray')  # Assuming grayscale image
plt.axis('off')
plt.title('Reconstructed Image')
plt.show()

# Create a 1x4 subplot
fig, axes = plt.subplots(1, 3, figsize=(16, 4))

# Plot the images on each subplot
axes[0].imshow(reconstructed_image, cmap='gray')
axes[0].set_title('Pred')
axes[0].axis('off')

axes[1].imshow(reconstructed_original_image[:,:,0], cmap='gray')
axes[1].set_title('VV')
axes[1].axis('off')

axes[2].imshow(reconstructed_original_image[:,:,1], cmap='gray')
axes[2].set_title('VH')
axes[2].axis('off')

# Adjust layout
plt.tight_layout()
plt.show()